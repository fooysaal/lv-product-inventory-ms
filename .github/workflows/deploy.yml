name: CD - Deploy to Server

on:
  push:
    branches:
      - main # Deploy to production
      - staging # Deploy to staging
  workflow_dispatch: # Allow manual deployment
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        type: choice
        options:
          - staging
          - production

jobs:
  deploy:
    name: Deploy to ${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'staging') }}
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'staging') }}
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set environment variables
        run: |
          if [[ "${{ github.event.inputs.environment }}" == "production" ]] || [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "DEPLOY_HOST=${{ secrets.PROD_HOST }}" >> $GITHUB_ENV
            echo "DEPLOY_USER=${{ secrets.PROD_USER }}" >> $GITHUB_ENV
            echo "DEPLOY_PATH=${{ secrets.PROD_PATH }}" >> $GITHUB_ENV
            echo "APP_URL=${{ secrets.PROD_URL }}" >> $GITHUB_ENV
            echo "ENV_NAME=production" >> $GITHUB_ENV
          else
            echo "DEPLOY_HOST=${{ secrets.STAGING_HOST }}" >> $GITHUB_ENV
            echo "DEPLOY_USER=${{ secrets.STAGING_USER }}" >> $GITHUB_ENV
            echo "DEPLOY_PATH=${{ secrets.STAGING_PATH }}" >> $GITHUB_ENV
            echo "APP_URL=${{ secrets.STAGING_URL }}" >> $GITHUB_ENV
            echo "ENV_NAME=staging" >> $GITHUB_ENV
          fi

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ env.DEPLOY_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to server
        id: deploy
        run: |
          ssh ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} "bash -s" << 'ENDSSH'
            set -e

            # Define paths
            DEPLOY_ROOT="${{ env.DEPLOY_PATH }}"
            RELEASE_NAME=$(date +%Y%m%d-%H%M%S)
            RELEASE_PATH="${DEPLOY_ROOT}/releases/${RELEASE_NAME}"
            CURRENT_LINK="${DEPLOY_ROOT}/current"
            SHARED_PATH="${DEPLOY_ROOT}/shared"

            # Create directory structure if it doesn't exist
            mkdir -p "${DEPLOY_ROOT}/releases"
            mkdir -p "${SHARED_PATH}/storage"
            mkdir -p "${SHARED_PATH}/storage/app"
            mkdir -p "${SHARED_PATH}/storage/framework/cache"
            mkdir -p "${SHARED_PATH}/storage/framework/sessions"
            mkdir -p "${SHARED_PATH}/storage/framework/views"
            mkdir -p "${SHARED_PATH}/storage/logs"

            # Clone the repository into the new release directory
            # Note: For private repositories, ensure SSH keys are properly configured on the server
            # or use a personal access token: https://TOKEN@github.com/${{ github.repository }}.git
            git clone --depth 1 --branch ${{ github.ref_name }} https://github.com/${{ github.repository }}.git "${RELEASE_PATH}"

            # Create .env symlink if shared .env exists
            if [ -f "${SHARED_PATH}/.env" ]; then
              ln -nfs "${SHARED_PATH}/.env" "${RELEASE_PATH}/.env"
            else
              echo "Warning: No .env file found in ${SHARED_PATH}/.env"
              # Copy .env.example as a fallback
              cp "${RELEASE_PATH}/.env.example" "${RELEASE_PATH}/.env"
            fi

            # Link shared storage directory
            if [ -d "${RELEASE_PATH}/storage" ]; then
              rm -rf "${RELEASE_PATH}/storage"
            fi
            ln -nfs "${SHARED_PATH}/storage" "${RELEASE_PATH}/storage"

            # Navigate to release directory
            cd "${RELEASE_PATH}"

            # Install/update Composer dependencies
            composer install --no-dev --optimize-autoloader --no-interaction

            # Install/update NPM dependencies and build assets
            npm ci
            npm run build

            # Run database migrations
            php artisan migrate --force

            # Clear and cache config
            php artisan config:cache
            php artisan route:cache
            php artisan view:cache

            # Clear application cache
            php artisan cache:clear

            # Set permissions
            chmod -R 775 storage bootstrap/cache

            # Save the current release path for potential rollback
            if [ -L "${CURRENT_LINK}" ]; then
              PREVIOUS_RELEASE=$(readlink "${CURRENT_LINK}")
              echo "${PREVIOUS_RELEASE}" > "${DEPLOY_ROOT}/.previous_release"
            fi

            # Switch the current symlink to the new release
            ln -nfs "${RELEASE_PATH}" "${CURRENT_LINK}"

            # Restart queue workers (using the current symlink)
            cd "${CURRENT_LINK}"
            php artisan queue:restart

            # Clean up old releases (keep last 5 releases)
            cd "${DEPLOY_ROOT}/releases"
            # Only delete directories that match the timestamp pattern (YYYYMMDD-HHMMSS)
            ls -1t | grep -E '^[0-9]{8}-[0-9]{6}$' | tail -n +6 | while read -r old_release; do
              if [ -d "${old_release}" ]; then
                echo "Removing old release: ${old_release}"
                rm -rf "${old_release}"
              fi
            done

            echo "Deployment completed successfully"
            echo "Release: ${RELEASE_NAME}"
          ENDSSH

          echo "url=${{ env.APP_URL }}" >> $GITHUB_OUTPUT

      - name: Deployment notification
        if: success()
        run: |
          echo "‚úÖ Successfully deployed to ${{ env.ENV_NAME }}"
          echo "üåê URL: ${{ env.APP_URL }}"

      - name: Rollback on failure
        if: failure()
        run: |
          ssh ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} "bash -s" << 'ENDSSH'
            set -e

            # Define paths
            DEPLOY_ROOT="${{ env.DEPLOY_PATH }}"
            CURRENT_LINK="${DEPLOY_ROOT}/current"
            PREVIOUS_RELEASE_FILE="${DEPLOY_ROOT}/.previous_release"

            # Check if we have a previous release to rollback to
            if [ -f "${PREVIOUS_RELEASE_FILE}" ]; then
              PREVIOUS_RELEASE=$(cat "${PREVIOUS_RELEASE_FILE}")
              
              if [ -d "${PREVIOUS_RELEASE}" ]; then
                echo "Rolling back to previous release: ${PREVIOUS_RELEASE}"
                
                # Switch the current symlink back to the previous release
                ln -nfs "${PREVIOUS_RELEASE}" "${CURRENT_LINK}"
                
                # Restart services with the previous release
                cd "${CURRENT_LINK}"
                php artisan queue:restart
                php artisan config:cache
                php artisan route:cache
                php artisan view:cache
                
                echo "‚úÖ Rollback completed successfully"
              else
                echo "‚ö†Ô∏è Previous release directory not found: ${PREVIOUS_RELEASE}"
                echo "Cannot rollback - manual intervention required"
                exit 1
              fi
            else
              echo "‚ö†Ô∏è No previous release information found"
              echo "This might be the first deployment - manual intervention required"
              exit 1
            fi
          ENDSSH
          echo "‚ö†Ô∏è Deployment failed - rolled back to previous version"
